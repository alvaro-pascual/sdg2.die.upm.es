#include <stdlib.h>  // para el NULL
#include <stdio.h>
#include <wiringPi.h>
#include "fsm.h"
#include "tmr.h"


#define CLK_MS 10
#define TIMEOUT_P 10000
#define TIMEOUT_C 5000

#define GPIO_PULSADOR_1 19
#define GPIO_PULSADOR_2 20
#define GPIO_PULSADOR_3 21
#define GPIO_PULSADOR_4 26
#define GPIO_PULSADOR_START 27

#define GPIO_LED_1 11
#define GPIO_LED_2 14
#define GPIO_LED_3 17
#define GPIO_LED_4 18
#define GPIO_LED_START 22

#define FLAG_PULSADOR_1	0x01
#define FLAG_PULSADOR_2	0x02
#define FLAG_PULSADOR_3	0x04
#define FLAG_PULSADOR_4 0x08
#define FLAG_PULSADOR_START 0x16
#define FLAG_TIMER 0x32

#define NUM_LEDS_ENCENDIDOS 15


enum fsm_state {
	WAIT_START,
	WAIT_PUSH,
	WAIT_END,
	EXCTN_WAIT_END
};

int led_encendido=0;
int led=0;

int encender_led_random(){

	//inserte codigo aqui, asignar led_encendido como si fuese un flag similar a pulsador
	int numero;

	numero = rand() % 4 + 1;
	if(numero<1){
		led_encendido|= FLAG_PULSADOR_1;
		led=1;
	}
	else if(numero<2){
		led_encendido|= FLAG_PULSADOR_2;
		led=2;
	}
	else if(numero<3){
		led_encendido|= FLAG_PULSADOR_3;
		led=3;
	}
	else{
		led_encendido|= FLAG_PULSADOR_4;
		led=4;
	}
	return led;

}


int flags = 0;
int num_pulsa=0;
void boton_p1_isr (void) { flags|= FLAG_PULSADOR_1; }
void boton_p2_isr (void) { flags|= FLAG_PULSADOR_2; }
void boton_p3_isr (void) { flags|= FLAG_PULSADOR_3; }
void boton_p4_isr (void) { flags|= FLAG_PULSADOR_4; }
void boton_pStart_isr (void) { flags|= FLAG_PULSADOR_START; }
void timer_isr (union sigval value) {flags|= FLAG_TIMER; }

int event_btn_start_end (fsm_t* this) { return (flags& FLAG_PULSADOR_START); }
int event_btn_fail (fsm_t* this) { return ((flags& FLAG_TIMER) || comp_fail(led_encendido)); }
int event_btn_ok (fsm_t* this) { return (comp_ok(led_encendido)); }
int event_exception (fsm_t* this) { return (comp_exception()); }
int event_end_game (fsm_t* this) { return (num_pulsa==NUM_LEDS_ENCENDIDOS); }


//funcion que comprueba si hemos fallado al pulsar el boton
int comp_fail(int led){
	return ~(led& flags);
}

//funcion que comprueba si hemos acertado al pulsar el boton
int comp_ok(int led){
	return (led& flags);
}

int comp_exception(){


}



/*
int pulsado_p (fsm_t* this) { return (flags& FLAG_BOTON_P); }
int pulsado_c1 (fsm_t* this) { return (flags& FLAG_BOTON_C1); }
int pulsado_c2 (fsm_t* this) { return (flags& FLAG_BOTON_C2); }
int timeout (fsm_t* this) { return (flags& FLAG_TIMER); }

void enciende_p (fsm_t* this) {
	flags &= (~FLAG_BOTON_P);//Limpia flag
	digitalWrite(GPIO_LIGHT_P, 1);//Enciende luz
	tmr_startms((tmr_t*)(this->user_data), TIMEOUT_P);//Lanza cuenta
}
void enciende_l1_1 (fsm_t* this) {
	flags &= (~FLAG_BOTON_C1);//Limpia flag
	digitalWrite(GPIO_LIGHT_L1_1, 1);//Enciende luz
	tmr_startms((tmr_t*)(this->user_data), TIMEOUT_C);//Lanza cuenta
}
void enciende_l1_2 (fsm_t* this) {
	flags &= (~FLAG_BOTON_C1);//Limpia flag
	digitalWrite(GPIO_LIGHT_L1_2, 1);//Enciende luz
	tmr_startms((tmr_t*)(this->user_data), TIMEOUT_C);
}
void enciende_l2_1 (fsm_t* this) {
	flags &= (~FLAG_BOTON_C2);
	digitalWrite(GPIO_LIGHT_L2_1, 1);
	tmr_startms((tmr_t*)(this->user_data), TIMEOUT_C);
}
void enciende_l2_2 (fsm_t* this) {
	flags &= (~FLAG_BOTON_C2);//
	digitalWrite(GPIO_LIGHT_L2_2, 1);
	tmr_startms((tmr_t*)(this->user_data), TIMEOUT_C);
}
*/
void s1e1(){

}
void s2e2(){

}
void s2e3(){

}
void s2e4(){

}
void s2e5(){

}
void s3e1(){

}



void apagar   (fsm_t* this) {
	flags &= (~FLAG_TIMER);//Limpia flags
	digitalWrite(GPIO_LED_1, 0);
	digitalWrite(GPIO_LED_2, 0);//Apaga luces
	digitalWrite(GPIO_LED_3, 0);
	digitalWrite(GPIO_LED_4, 0);
	digitalWrite(GPIO_LED_START, 1);
}

// wait until next_activation (absolute time)
void delay_until (unsigned int next)
{
  unsigned int now = millis();
  if (next > now) {
	  delay (next - now);
  }
}

int main ()
{
	tmr_t* tmr = tmr_new (timer_isr);//user_data: instancia del timer

	fsm_trans_t tv_tt[] = {
			{WAIT_START, event_btn_start_end, WAIT_PUSH, s1e1},
			{WAIT_PUSH, event_btn_ok, WAIT_PUSH, s2e2},
			{WAIT_PUSH, event_btn_fail, WAIT_PUSH, s2e3},
			{WAIT_PUSH, event_end_game, WAIT_END, s2e4},
			{WAIT_PUSH, event_exception, EXCTN_WAIT_END, s2e5},
			{EXCTN_WAIT_END, event_btn_start_end, WAIT_START, s3e1},
			{WAIT_END, event_btn_start_end, WAIT_START, s3e1},

			/*

			{IDLE, pulsado_c1, WAIT_LED, enciende_l1_2},
			{IDLE, pulsado_c2, WAIT_LED, enciende_l2_2},
			{WAIT_BUT, timeout,IDLE, apagar},
			{WAIT_BUT, pulsado_c1,WAIT_LED, enciende_l1_1},
			{WAIT_BUT, pulsado_c2,WAIT_LED, enciende_l2_1},
			{WAIT_LED, timeout,IDLE, apagar},*/
			{-1, NULL, -1, NULL}
	};

	fsm_t* tv_fsm = fsm_new (WAIT_START, tv_tt, tmr);
	unsigned int next;

	wiringPiSetupGpio();
	pinMode(GPIO_PULSADOR_1, INPUT);
	pinMode(GPIO_PULSADOR_2, INPUT);
	pinMode(GPIO_PULSADOR_3, INPUT);
	pinMode(GPIO_PULSADOR_4, INPUT);
	pinMode(GPIO_PULSADOR_START, INPUT);
	pinMode(GPIO_LED_1, OUTPUT);
	pinMode(GPIO_LED_2, OUTPUT);
	pinMode(GPIO_LED_3, OUTPUT);
	pinMode(GPIO_LED_4, OUTPUT);
	pinMode(GPIO_LED_START, OUTPUT);

	wiringPiISR(GPIO_PULSADOR_1, INT_EDGE_FALLING, boton_p1_isr);
	wiringPiISR(GPIO_PULSADOR_2, INT_EDGE_FALLING, boton_p2_isr);
	wiringPiISR(GPIO_PULSADOR_3, INT_EDGE_FALLING, boton_p3_isr);
	wiringPiISR(GPIO_PULSADOR_4, INT_EDGE_FALLING, boton_p4_isr);
	wiringPiISR(GPIO_PULSADOR_START, INT_EDGE_FALLING, boton_pStart_isr);


	apagar(tv_fsm);
	//Configuración de GPIO: modo, interrupciones
	//Ejecutar función para inicializar los recursos: salidas, timer, flags, ...

	next = millis();
	while (1) {
		fsm_fire (tv_fsm);
		next += CLK_MS;
		delay_until (next);
	}

	tmr_destroy((tmr_t*)tv_fsm->user_data);//Destruir user_data
	fsm_destroy(tv_fsm);//Destruir maquina de estados
}
